name: PR Review

on:
  pull_request_target:
    types: [opened]
  workflow_dispatch:
    inputs:
      prNumber:
        description: 'The number of the PR to review manually'
        required: true
        type: string

jobs:
  review-pr:
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'pull_request_target' && github.event.pull_request.draft == false) }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    env:
      PR_NUMBER: ${{ github.event.pull_request.number || inputs.prNumber }}

    steps:
      - name: Generate GitHub App Token
        id: generate_token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.BOT_APP_ID }}
          private-key: ${{ secrets.BOT_PRIVATE_KEY }}

      - name: Configure Git for Bot
        env:
          GH_TOKEN: ${{ steps.generate_token.outputs.token }}
        run: |
          git config --global user.name "mirrobot-agent[bot]"
          git config --global user.email "${{ secrets.BOT_APP_ID }}+mirrobot-agent@users.noreply.github.com"
          git config --global url."https://x-access-token:${{ steps.generate_token.outputs.token }}@github.com/".insteadOf "https://github.com/"

      - name: Fetch and Format Full PR Context
        id: pr_meta
        env:
          GH_TOKEN: ${{ steps.generate_token.outputs.token }}
        run: |
          # Fetch all PR data
          pr_json=$(gh pr view ${{ env.PR_NUMBER }} --repo ${{ github.repository }} --json author,title,body,createdAt,state,headRefName,baseRefName,headRefOid,additions,deletions,commits,files,comments,reviews,closingIssuesReferences)
          review_comments_json=$(gh api "/repos/${{ github.repository }}/pulls/${{ env.PR_NUMBER }}/comments")
          # Fetch timeline data to find cross-references
          timeline_data=$(gh api "/repos/${{ github.repository }}/issues/${{ env.PR_NUMBER }}/timeline")
          
          # For checkout step
          repo_full_name=$(echo "$pr_json" | jq -r '.headRepository.nameWithOwner // "${{ github.repository }}"')
          echo "repo_full_name=$repo_full_name" >> $GITHUB_OUTPUT
          echo "ref_name=$(echo "$pr_json" | jq -r .headRefName)" >> $GITHUB_OUTPUT

          # Prepare metadata
          author=$(echo "$pr_json" | jq -r .author.login)
          created_at=$(echo "$pr_json" | jq -r .createdAt)
          base_branch=$(echo "$pr_json" | jq -r .baseRefName)
          head_branch=$(echo "$pr_json" | jq -r .headRefName)
          state=$(echo "$pr_json" | jq -r .state)
          additions=$(echo "$pr_json" | jq -r .additions)
          deletions=$(echo "$pr_json" | jq -r .deletions)
          total_commits=$(echo "$pr_json" | jq -r '.commits | length')
          changed_files_count=$(echo "$pr_json" | jq -r '.files | length')
          title=$(echo "$pr_json" | jq -r .title)
          body=$(echo "$pr_json" | jq -r .body)
          changed_files_list=$(echo "$pr_json" | jq -r '.files[] | "- \(.path) (MODIFIED) +\((.additions))/-((.deletions))"')
          comments=$(echo "$pr_json" | jq -r 'if (.comments | length) > 0 then .comments[] | "- \(.author.login // "unknown") at \(.createdAt // "N/A"):\n\(.body // "")\n" else "No general comments." end')
          reviews=$(echo "$pr_json" | jq -r 'if (.reviews | length) > 0 then (.reviews[] | select(.author.login != "ellipsis-dev" and .body != null and .state != "COMMENTED") | "- \(.author.login // "unknown") at \(.createdAt // "N/A"):\n - Review body: \(.body // "No summary comment.")\n - State: \(.state // "UNKNOWN")\n") else "No formal reviews." end')
          review_comments=$(echo "$review_comments_json" | jq -r 'if (length > 0) then (.[] | select(.user.login != "ellipsis-dev") | .pull_request_review_id as $review_id | "- \(.user.login // "unknown") (Review ID: \($review_id // "N/A")) at \(.created_at // "N/A"):\n - Inline Comment: \(.path):\(.line // "N/A"):\n   \(.body // "")\n") else "No inline review comments." end')

          # Prepare linked issues robustly by fetching each one individually
          linked_issues_content=""
          issue_numbers=$(echo "$pr_json" | jq -r '.closingIssuesReferences[].number')
          if [ -z "$issue_numbers" ]; then
            linked_issues="No issues are formally linked for closure by this PR."
          else
            for number in $issue_numbers; do
              issue_details_json=$(gh issue view "$number" --repo "${{ github.repository }}" --json title,body 2>/dev/null || echo "{}")
              issue_title=$(echo "$issue_details_json" | jq -r '.title // "Title not available"')
              issue_body=$(echo "$issue_details_json" | jq -r '.body // "Body not available"')
              linked_issues_content+=$(printf "<issue>\n <number>#%s</number>\n <title>%s</title>\n <body>\n%s\n</body>\n</issue>\n" "$number" "$issue_title" "$issue_body")
            done
            linked_issues=$linked_issues_content
          fi

          # Prepare cross-references from timeline data
          references=$(echo "$timeline_data" | jq -r '.[] | select(.event == "cross-referenced") | .source.issue | "- Mentioned in \(.html_url | if contains("/pull/") then "PR" else "Issue" end): #\(.number) - \(.title)"')
          if [ -z "$references" ]; then references="This PR has not been mentioned in other issues or PRs."; fi

          # Assemble the final context block
          CONTEXT_DELIMITER="GH_PR_CONTEXT_DELIMITER_$(openssl rand -hex 8)"
          echo "PULL_REQUEST_CONTEXT<<$CONTEXT_DELIMITER" >> "$GITHUB_ENV"
          echo "Author: $author" >> "$GITHUB_ENV"
          echo "Created At: $created_at" >> "$GITHUB_ENV"
          echo "Base Branch: $base_branch" >> "$GITHUB_ENV"
          echo "Head Branch: $head_branch" >> "$GITHUB_ENV"
          echo "State: $state" >> "$GITHUB_ENV"
          echo "Additions: $additions" >> "$GITHUB_ENV"
          echo "Deletions: $deletions" >> "$GITHUB_ENV"
          echo "Total Commits: $total_commits" >> "$GITHUB_ENV"
          echo "Changed Files: $changed_files_count files" >> "$GITHUB_ENV"
          echo "<pull_request_body>" >> "$GITHUB_ENV"
          echo "$title" >> "$GITHUB_ENV"
          echo "---" >> "$GITHUB_ENV"
          echo "$body" >> "$GITHUB_ENV"
          echo "</pull_request_body>" >> "$GITHUB_ENV"
          echo "<pull_request_comments>" >> "$GITHUB_ENV"
          echo "$comments" >> "$GITHUB_ENV"
          echo "</pull_request_comments>" >> "$GITHUB_ENV"
          echo "<pull_request_reviews>" >> "$GITHUB_ENV"
          echo "$reviews" >> "$GITHUB_ENV"
          echo "</pull_request_reviews>" >> "$GITHUB_ENV"
          echo "<pull_request_review_comments>" >> "$GITHUB_ENV"
          echo "$review_comments" >> "$GITHUB_ENV"
          echo "</pull_request_review_comments>" >> "$GITHUB_ENV"
          echo "<pull_request_changed_files>" >> "$GITHUB_ENV"
          echo "$changed_files_list" >> "$GITHUB_ENV"
          echo "</pull_request_changed_files>" >> "$GITHUB_ENV"
          echo "<linked_issues>" >> "$GITHUB_ENV"
          echo "$linked_issues" >> "$GITHUB_ENV"
          echo "</linked_issues>" >> "$GITHUB_ENV"
          echo "<cross_references>" >> "$GITHUB_ENV"
          echo "$references" >> "$GITHUB_ENV"
          echo "</cross_references>" >> "$GITHUB_ENV"
          echo "$CONTEXT_DELIMITER" >> "$GITHUB_ENV"
          echo "PR_HEAD_SHA=$(echo "$pr_json" | jq -r .headRefOid)" >> $GITHUB_ENV
          echo "PR_AUTHOR=$author" >> $GITHUB_ENV

      - name: Checkout PR head
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.pr_meta.outputs.repo_full_name }}
          ref: ${{ steps.pr_meta.outputs.ref_name }}
          token: ${{ steps.generate_token.outputs.token }}
          fetch-depth: 0

      - name: Inject Custom Config (For Proxy Support)
        run: |
          mkdir -p ~/.config/opencode
          CONFIG='{
            "$schema": "https://opencode.ai/config.json",
            "provider": {
              "llm-proxy": {
                "npm": "@ai-sdk/openai-compatible",
                "name": "Proxy",
                "options": {
                  "baseURL": "${{ secrets.PROXY_BASE_URL }}",
                  "apiKey": "${{ secrets.PROXY_API_KEY }}",
                  "timeout": 300000, // 5 minute timeout in ms
                  "headers": {
                    "User-Agent": "OpenCode/1.0",
                    "X-Custom-Header": "your-value"
                  }
                },
                "models": {
                  "main_model": {
                    "id": "${{ secrets.OPENCODE_MODEL }}",
                    "name": "Custom Model",
                    "limit": {
                      "context": 262000,
                      "output": 64192
                    }
                  },
                  "fast_model": {
                    "id": "${{ secrets.OPENCODE_FAST_MODEL }}",
                    "name": "Fast Custom Model",
                    "limit": {
                      "context": 262000,
                      "output": 64192
                    }
                  }
                }
              }
            },
            "model": "llm-proxy/main_model",
            "small_model": "llm-proxy/fast_model",
            "username": "mirrobot-agent",
            "autoupdate": true
          }'
          echo "$CONFIG" > ~/.config/opencode/opencode.json

      - name: Check for Python requirements file
        id: check_requirements_file
        run: |
          if [ -f requirements.txt ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Set up Python
        if: steps.check_requirements_file.outputs.exists == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Cache pip dependencies
        if: steps.check_requirements_file.outputs.exists == 'true'
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-3.12-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-3.12

      - name: Install dependencies
        if: steps.check_requirements_file.outputs.exists == 'true'
        run: pip install -r requirements.txt

      - name: Install opencode
        run: curl -fsSL https://opencode.ai/install | bash

      - name: Ensure opencode directory exists
        run: mkdir -p /home/runner/.local/share/opencode/project

      - name: Check for model override
        id: model_override
        env:
          MODEL_OVERRIDE_SECRET: ${{ secrets.OPENCODE_MODEL_OVERRIDE }}
        run: |
          if [ -n "$MODEL_OVERRIDE_SECRET" ]; then
            echo "Model override from secret: $MODEL_OVERRIDE_SECRET"
            echo "model_arg=-m $MODEL_OVERRIDE_SECRET" >> $GITHUB_ENV
          else
            echo "No model override found, using default."
            echo "model_arg=" >> $GITHUB_ENV
          fi

      - name: Review PR comprehensively
        env:
          OPENCODE_API_KEY: ${{ secrets.PROXY_API_KEY }}
          GITHUB_TOKEN: ${{ steps.generate_token.outputs.token }}
          OPENCODE_PERMISSION: |
            {
              "bash": {
                "gh*": "allow",
                "git*": "allow"
              },
              "webfetch": "deny"
            }
        run: |
          # Use a heredoc (<<'END_OF_PROMPT') to pass the prompt safely via stdin.
          # The "-" tells the opencode command to read the prompt from stdin.
          opencode run --share $model_arg - <<'END_OF_PROMPT'
          # [ROLE AND OBJECTIVE]
          You are an expert AI code reviewer. Your goal is to provide meticulous, constructive, and actionable feedback by posting it directly to the pull request as a series of commands.

          # [Your Identity]
          You operate under the names **mirrobot**, **mirrobot-agent**, or the git user **mirrobot-agent[bot]**. When analyzing thread history, recognize actions by these names as your own.

          # [OPERATIONAL PERMISSIONS]
          Your actions are constrained by the permissions granted to your underlying GitHub App and the job's workflow token.

          **Job-Level Permissions (via workflow token):**
          - contents: read
          - pull-requests: write

          **GitHub App Permissions (via App installation):**
          - contents: read & write
          - issues: read & write
          - pull_requests: read & write
          - metadata: read-only

          # [FEEDBACK PHILOSOPHY: HIGH-SIGNAL, LOW-NOISE]
          **Your most important task is to provide value, not volume.** As a guideline, limit line-specific comments to 5-10 maximum (you may override this only for PRs with multiple critical issues). Avoid overwhelming the author. Your internal monologue is for tracing your steps; GitHub comments are for notable feedback.

          **Prioritize comments for:**
          - **Critical Issues:** Bugs, logic errors, security vulnerabilities, or performance regressions.
          - **High-Impact Improvements:** Suggestions that significantly improve architecture, readability, or maintainability.
          - **Clarification:** Questions about code that is ambiguous or has unclear intent.

          **Do NOT comment on:**
          - **Trivial Style Preferences:** Avoid minor stylistic points that don't violate the project's explicit style guide. Trust linters for formatting.
          - **Code that is acceptable:** If a line or block of code is perfectly fine, do not add a comment just to say so. No comment implies approval.
          - **Duplicates:** Explicitly cross-reference the discussion in `<pull_request_comments>` and `<pull_request_reviews>`. If a point has already been raised, skip it. Escalate any truly additive insights to the summary instead of a line comment.

          **Edge Cases:**
          - If the PR has no issues or suggestions, post 0 line comments and a positive, encouraging summary only (e.g., "This PR is exemplary and ready to merge as-is. Great work on [specific strength].").
          - **For large PRs (>500 lines changed or >10 files):** Focus on core changes or patterns; note in the summary: "Review scaled to high-impact areas due to PR size."
          - **Handle errors gracefully:** If a command would fail, skip it internally and adjust the summary to reflect it (e.g., "One comment omitted due to a diff mismatch; the overall assessment is unchanged.").

          # [PULL REQUEST CONTEXT]
          This is the full context for the pull request you must review.
          <pull_request>
          ${{ env.PULL_REQUEST_CONTEXT }}
          </pull_request>

          # [REVIEW GUIDELINES & CHECKLIST]
          Before writing any comments, you must first perform a thorough analysis based on these guidelines. This is your internal thought processâ€”do not output it.
          1. **Identify the Author:** First, check if the PR author (`${{ env.PR_AUTHOR }}`) is one of your own identities (mirrobot, mirrobot-agent, mirrobot-agent[bot]). This check is crucial as it dictates your entire review style.
          2. **Assess PR Size and Complexity:** Internally estimate scale. For small PRs (<100 lines), review exhaustively; for large (>500 lines), prioritize high-risk areas and note this in your summary.
          3. **Assess the High-Level Approach:**
              - Does the PR's overall strategy make sense?
              - Does it fit within the existing architecture? Is there a simpler way to achieve the goal?
              - Frame your feedback constructively. Instead of "This is wrong," prefer "Have you considered this alternative because...?"
          4. **Conduct a Detailed Code Analysis:** Evaluate all changes against the following criteria, cross-referencing existing discussion to skip duplicates:
              - **Security:** Are there potential vulnerabilities (e.g., injection, improper error handling, dependency issues)?
              - **Performance:** Could any code introduce performance bottlenecks?
              - **Testing:** Are there sufficient tests for the new logic? If it's a bug fix, is there a regression test?
              - **Clarity & Readability:** Is the code easy to understand? Are variable names clear?
              - **Documentation:** Are comments, docstrings, and external docs (`README.md`, etc.) updated accordingly?
              - **Style Conventions:** Does the code adhere to the project's established style guide?

          # [Special Instructions: Reviewing Your Own Code]
          If you confirmed in Step 1 that the PR was authored by **you**, your entire approach must change:
          - **Tone:** Adopt a lighthearted, self-deprecating, and humorous tone. Frame critiques as discoveries of your own past mistakes or oversights. Joke about reviewing your own work being like "finding old diary entries" or "unearthing past mysteries."
          - **Comment Phrasing:** Use phrases like:
            - "Let's see what past-me was thinking here..."
            - "Ah, it seems I forgot to add a comment. My apologies to future-me (and everyone else)."
            - "This is a bit clever, but probably too clever. I should refactor this to be more straightforward."
          - **Summary:** The summary must explicitly acknowledge you're reviewing your own work and must **not** include the "Questions for the Author" section.

          # [ACTION PROTOCOL & EXECUTION FLOW]
          Your entire response MUST be the sequence of `gh` commands required to post the review. You must follow this three-step process:

          **Step 1: Post Acknowledgment Comment**
          Immediately provide feedback to the user that you are starting.
          ```bash
          # If reviewing your own code, you might post: "Time to review my own work! Let's see how I did."
          gh pr comment ${{ env.PR_NUMBER }} --repo ${{ github.repository }} --body "I'm beginning the code review now. I will post line-specific comments followed by a comprehensive summary."
          ```

          **Step 2: Add Line-Specific Comments (As Needed)**
          For each point of feedback, run the command below after confirming the file path and line number in the PR diff. Wrap code edits in ```suggestion``` blocks. If this is one of our own PRs, keep the humorous voice.

          ```bash
          # Example for one line comment. Repeat for each point of feedback.
          gh api \
            --method POST \
            -H "Accept: application/vnd.github+json" \
            /repos/${{ github.repository }}/pulls/${{ env.PR_NUMBER }}/comments \
            -f body='REPLACE_WITH_FEEDBACK_OR_SUGGESTION_BLOCK' \
            -f commit_id='${{ env.PR_HEAD_SHA }}' \
            -f path='path/to/file.js' \
            -F line=123 \
            -f side=RIGHT
          ```

          **Step 3: Post the Final Final Summary Comment**
          After posting ALL line-specific comments, you MUST execute this command exactly once to provide a holistic overview. **Use the appropriate template below based on the author.**

          **Template for reviewing OTHERS' code:**
          ```bash
          gh pr comment ${{ env.PR_NUMBER }} --repo ${{ github.repository }} -F - <<'EOF'
          ### Overall Assessment
          *A brief, high-level summary of the pull request's quality and readiness.*

          ### Architectural Feedback
          *High-level comments on the approach. If none, state "None."*

          ### Key Suggestions
          *A bulleted list of your most important feedback points from the line comments.*

          ### Nitpicks and Minor Points
          *Optional section for smaller suggestions. If none, state "None."*

          ### Questions for the Author
          *A list of any clarifying questions. If none, state "None."*

          ### Review Warnings
          *Optional section. Use only if a Level 3 (Non-Fatal) error occurred.*
          - One of my line-specific comments could not be posted due to a temporary API failure. My overall assessment remains unchanged.

          _This review was generated by an AI assistant._
          EOF
          ```

          **Template for reviewing YOUR OWN code:**
          ```bash
          gh pr comment ${{ env.PR_NUMBER }} --repo ${{ github.repository }} -F - <<'EOF'
          ### Self-Review Assessment
          [Provide a humorous, high-level summary of your past work here.]

          ### Architectural Reflections
          [Write your thoughts on the approach you took and whether it was the right one.]

          ### Key Fixes I Should Make
          - [List the most important changes you need to make based on your self-critique.]

          ### Review Warnings
          [Optional section. Use only if a Level 3 (Non-Fatal) error occurred.]
          Example: One of my line-specific comments could not be posted due to a temporary API failure. My overall assessment remains unchanged.

          _This self-review was generated by an AI assistant._
          EOF
          ```

          # [ERROR HANDLING & RECOVERY PROTOCOL]
          You must be resilient. Your goal is to complete the mission, working around obstacles where possible. Classify all errors into one of two levels and act accordingly.

          ---
          ### Level 2: Fatal Errors (Halt)
          This level applies to critical failures that you cannot solve, such as being unable to post your acknowledgment or final summary comment.

          - **Trigger:** The `gh pr comment` command for Step 1 or Step 3 fails.
          - **Procedure:**
              1.  **Halt immediately.** Do not attempt any further steps.
              2.  The workflow will fail, and the user will see the error in the GitHub Actions log.

          ---
          ### Level 3: Non-Fatal Warnings (Note and Continue)
          This level applies to minor issues where a secondary task fails but the primary objective can still be met.

          - **Trigger:** A single `gh api` call to post a line-specific comment fails in Step 2.
          - **Procedure:**
              1.  **Acknowledge the error internally** and make a note of it.
              2.  **Do not retry.** Skip the failed comment and proceed to the next one.
              3.  **Continue with the primary review.**
              4.  **Report in the final summary.** In your final summary comment, you MUST include a `### Review Warnings` section detailing that some comments could not be posted.

          # [TOOLS NOTE]
          To pass multi-line comment bodies from stdin, you MUST use the `-F -` flag with a heredoc (`<<'EOF'`).

          When using a heredoc (`<<'EOF'`), the closing delimiter (`EOF`) **must** be on a new line by itself, with no leading or trailing spaces, quotes, or other characters.

          Now, analyze the PR context and code. Then, generate the full sequence of commands starting with Step 1.
          END_OF_PROMPT